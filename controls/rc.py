import time
from http.server import HTTPServer

from lib.threading2 import LoggingExceptionsThread
from controls.base import ControlBase
from controls.rc_web import Web
from config import Config
from pathlib import Path
from lib.utils import who


class RC(ControlBase, LoggingExceptionsThread):
    """
        Cars remote controls via local HTTPServer. It starts blocking WebServer in its thread whenever it fails to start + showing component status with actions generated by this control.
        * output = responding GET requests by giving WebPage content
        * input = responding POST requests from WebPage buttons > translate to actions for engine actuator
    """
    def __init__(self, control) -> None:
        super().__init__(period=10, control=control)
        LoggingExceptionsThread.__init__(self)
        Web._control = self._control
        self.components = [
            WebServer(Config.RC_HTTP_SERVER),
            WebServer(Config.ETH0_RC_HTTP_SERVER)
        ] if Path.exists(Path('/home/pi')) else [
            WebServer(Config.LOCAL_RC_HTTP_SERVER)  # local dev fake
        ]

    def stop(self):
        super().stop()
        [c.stop() for c in self.components]

    def iterate(self):
        [c.start() for c in self.components if not c.is_alive()]
        if self.last_exception:
            self.last_exception = None  # no exception raised in this iteration > all set

    @property
    def state(self) -> str:
        return f'{super().state}{"".join([c.state for c in self.components])}'


class WebServer(LoggingExceptionsThread):
    def __init__(self, address: tuple) -> None:
        super().__init__()
        self.address = address
        self.web_server = None
        self.retry_delay = 0

    def iterate(self):
        time.sleep(self.retry_delay)
        self.retry_delay = 2*self.retry_delay + 1
        self.logger.info(f'{who(self)} starting at: {self.address}')
        self.web_server = HTTPServer(self.address, Web)
        self.web_server.serve_forever()  # blocking, throwing exceptions > logged, retry by next iteration

    def stop(self):
        super().stop()
        if self.web_server:
            self.web_server.server_close()
            self.web_server.shutdown()
